from math import floor

import linecache
import numpy as np

from lib.workingWith3dDataSets import DataSet3d

'''
Function: openFile
'''


def openFile(file_name):
    """
    Opens a file and returns its content as a list of lines.

    Parameters:
    file_name (str): The name of the file to open.

    Returns:
    list: A list where each element is a stripped line from the file.
    """
    with open(file_name) as f:
        content = f.readlines()
    content = [x.strip() for x in content]
    return content


'''
Function: extractNodesFromINP
'''


def extractNodesFromINP(file_name, part, nodes):
    """
    Extracts the coordinates of the specified nodes from a given part in an Abaqus input file.

    Parameters:
        file_name (str): The name of the .inp file.
        part (str): The name of the part from which nodes should be extracted.
        nodes (list): A list of node numbers to be extracted.

    Returns:
        list: A list of node coordinates.

    Description:
        This function reads the content of the Abaqus input file specified by 'file_name' and extracts the coordinates
        of the specified nodes from the given 'part'. The node coordinates are extracted from the 'TissueCoordinates'
        array generated by calling the 'extractPointsForPartFrom' function.

        The function iterates over the provided 'nodes' list and retrieves the coordinates for each node from the
        'TissueCoordinates' array. The extracted node coordinates are added to the 'NodeCoordinates' list.

        The function returns a list of node coordinates.

    Example:
        >>> file_name = "input.inp"
        >>> part = "MyPart"
        >>> nodes = [1, 3, 5]
        >>> node_coordinates = extractNodesFromINP(file_name, part, nodes)
        >>> print(node_coordinates)
        [[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]]
    """
    TissueCoordinates = np.array(extractPointsForPartFrom(file_name, part, get_connections=False))
    #    print(TissueCoordinates)
    NodeCoordinates = []
    for i in nodes:
        NodeCoordinates.append(TissueCoordinates[i - 1])
    return NodeCoordinates


'''
Function: extractPointsForPartFrom
'''


def extractPointsForPartFrom(file_name, part, get_connections=False):
    """
    Extracts the points for a specified part from an Abaqus input file. It can also optionally return the connections between the points.

    Parameters:
        file_name (str): The name of the .inp file.
        part (str): The name of the part from which points should be extracted.
        get_connections (bool, optional): If true, also returns the connections between points.

    Returns:
        list: A list of point coordinates, and optionally a dictionary of connections.

    Description:
        This function reads an Abaqus input file specified by 'file_name' and extracts the points belonging to the specified 'part'. The 'part' is identified using the '*Part, name=' keyword followed by the part name.

        The function iterates through the lines of the file and collects the point coordinates belonging to the 'part'. The coordinates are stored as a list of lists, where each inner list represents the [x, y, z] coordinates of a point.

        If the 'get_connections' parameter is set to True, the function also extracts the connections between points and returns them as a dictionary. The dictionary uses the node number as the key and the connected nodes as the value.

        The extracted data is returned as a list of point coordinates, and if requested, a dictionary of connections. If the 'part' is not found in the input file, an empty list is returned.

    Note:
        - This function assumes that the Abaqus input file follows a specific format with valid syntax. Unexpected or malformed file structures may lead to incorrect results or errors.

    Example usage:
        >>> extractPointsForPartFrom('input.inp', 'MyPart', get_connections=True)
    """
    # print(file_name)
    content = openFile(file_name)

    found = False
    line_index = 1
    part = "*Part, name=" + part
    line_vals = []
    # connection_vals = []
    conVal = {}
    started = False
    started_connections = False
    for line in content:
        if not found and part not in line:
            continue  # go to next line
        elif found == False:
            found = True
        else:

            data = line.split(",")
            try:
                # if line contains the next expected node number
                if (int)(data[0]) == line_index:

                    # append data
                    started = True
                    if started_connections and get_connections:
                        # make a temp list contain the data in one line
                        temp = list(map(int, data[1:]))
                        # set the first item as a key and the after to be the value
                        conVal[temp[0]] = temp[1:]
                    else:

                        line_vals.append(data)

                    line_index += 1

                # if we have started parsing data and the next line is not our expected node number
                elif started:
                    # we have collected al the data
                    break
            # occurs at "*Node" after we have found part name
            except ValueError:
                if data[0] == "*Element" and get_connections:
                    started_connections = True
                    line_index = 1
                continue

    xyz_vals = []
    for data_point in line_vals:
        # the node values are strings and need to be converted to floats
        xyz_vals.append([float(data_point[1]), float(data_point[2]), float(data_point[3])])

    if get_connections:
        return xyz_vals, conVal
    else:
        return xyz_vals


'''
Function: extractPointsForPartFrom2
'''


def extractPointsForPartFrom2(file_name, part, get_connections=False):
    """
    Extracts the points for a specified part from an Abaqus input file. However, this version stores the connection values in a separate list.

    Parameters:
    file_name (str): The name of the .inp file.
    part (str): The name of the part from which points should be extracted.
    get_connections (bool, optional): If true, also returns the connections between points.

    Returns:
    list: A list of point coordinates, and a list of connections.
    """

    content = openFile(file_name)
    found = False
    line_index = 1
    part = "*Part, name=" + part
    line_vals = []
    connection_vals = []
    started = False
    started_connections = False
    for line in content:
        if not found and part not in line:
            continue  # go to next line
        elif found == False:
            found = True
        else:

            data = line.split(",")
            try:
                # if line contains the next expected node number
                if (int)(data[0]) == line_index:

                    # append data
                    started = True
                    if started_connections and get_connections:
                        temp = list(map(int, data[1:]))
                        connection_vals.append(temp)


                    else:

                        line_vals.append(data)

                    line_index += 1

                # if we have started parsing data and the next line is not our expected node number
                elif started:
                    # we have collected al the data
                    break
            # occurs at "*Node" after we have found part name
            except ValueError:
                if data[0] == "*Element" and get_connections:
                    started_connections = True
                    line_index = 1
                    continue
                else:
                    continue

    xyz_vals = []
    for data_point in line_vals:
        # the node values are strings and need to be converted to floats
        xyz_vals.append([float(data_point[1]), float(data_point[2]), float(data_point[3])])

    if get_connections:
        return xyz_vals, connection_vals
    else:
        return xyz_vals


'''
Function: write_new_inp_file
'''


def write_new_inp_file(file_name, part, new_file_name, data_set):
    """
    Writes a new Abaqus input file with updated node coordinates for a specified part.

    Parameters:
    file_name (str): The name of the original .inp file.
    part (str): The name of the part for which nodes should be updated.
    new_file_name (str): The name of the new .inp file to be written.
    data_set (DataSet3d): An instance of DataSet3d containing the new node coordinates.

    Returns:
    None
    """

    node_pad = 7  # how big of a space to leave for the data
    data_pad = 13  # this insures that of a number is 3 digits long it will be padded with spaces to the specified justifaction to maintian the given length

    content = openFile(file_name)
    new_file = open(new_file_name, 'w')
    write = False
    found = False
    part = "*Part, name=" + part
    index = 0
    max_index = data_set.number_of_points - 1
    for line in content:
        if write and max_index >= index:
            """
            The  node number is Justified right with a length of 7
            """
            line = (str(index + 1).rjust(node_pad) + ',' + str(data_set.xAxis[index]).rjust(data_pad) + ',' + str(
                data_set.yAxis[index]).rjust(data_pad) + ', ' + str(data_set.zAxis[index]).rjust(data_pad))
            new_file.write(line + "\n")
            index += 1
        else:
            new_file.write(line + "\n")

        if found and not write:
            write = True

        if part in line:
            found = True

    new_file.close()


'''
Function: write_part_to_inp_file
'''


def write_part_to_inp_file(file_name, part, data_set):
    """
    Writes directly to the existing Abaqus input file with updated node coordinates for a specified part.

    Parameters:
    file_name (str): The name of the .inp file.
    part (str): The name of the part for which nodes should be updated.
    data_set (DataSet3d): An instance of DataSet3d containing the new node coordinates.

    Returns:
    None
    """

    node_pad = 7  # how big of a space to leave for the data
    data_pad = 13  # this insures that of a number is 3 digits long it will be padded with spaces to the specified justifaction to maintian the given length
    #    print(file_name)
    content = openFile(file_name)
    f = open(file_name, 'w')
    write = False
    found = False
    part = "*Part, name=" + part
    index = 0
    max_index = data_set.number_of_points - 1
    for line in content:
        if write and max_index >= index:
            """
            The  node number is Justified right with a length of 7
            """
            line = (str(index + 1).rjust(node_pad) + ',' + str(data_set.xAxis[index]).rjust(data_pad) + ',' + str(
                data_set.yAxis[index]).rjust(data_pad) + ', ' + str(data_set.zAxis[index]).rjust(data_pad))
            f.write(line + "\n")
            index += 1
        else:
            f.write(line + "\n")

        if found and not write:
            write = True

        if part in line:
            found = True

    f.close()


'''
Function: get_dataset_from_file

Extracts points but puts it into DataSet3d class
'''


def get_dataset_from_file(file_name, part_name):
    """
    Extracts points from a part in an Abaqus input file and returns them as an instance of the DataSet3d class.

    Parameters:
        file_name (str): The name of the .inp file.
        part_name (str): The name of the part from which points should be extracted.

    Returns:
        DataSet3d: An instance of DataSet3d containing the extracted points.

    Description:
        This function reads an Abaqus input file specified by 'file_name' and extracts the points belonging to the specified 'part_name'.
        The 'part_name' is identified using the '*Part, name=' keyword followed by the part name.

        The function utilizes the 'extractPointsForPartFrom' function to extract the points for the specified part.
        The extracted points are then converted to a numpy array and stored in the 'np_points' variable.

        Finally, the function creates an instance of the DataSet3d class using the extracted x, y, and z coordinates from 'np_points'
        and returns it as the result.

    Example usage:
        >>> dataset = get_dataset_from_file('input.inp', 'MyPart')
    """
    #    print(file_name, part_name)
    np_points = np.array(extractPointsForPartFrom(file_name, part_name))
    #    print(np_points)
    return DataSet3d(list(np_points[:, 0]), list(np_points[:, 1]), list(np_points[:, 2]))


'''
Function: get_interconnections
'''


def get_interconnections(file_name, part_name):  # connections-between-material
    """
    Extracts the interconnections between nodes in a specified part from an Abaqus input file.

    Parameters:
    file_name (str): The name of the .inp file.
    part_name (str): The name of the part from which interconnections should be extracted.

    Returns:
    list: A list of lists, where each sublist contains the node numbers connected to the corresponding node.
    """

    connections = []
    number_of_nodes = len(extractPointsForPartFrom(file_name, part_name))

    # creates a list of empty nodes
    for i in range(0, number_of_nodes):
        connections.append([])

    findLine = "*Part, name=" + part_name

    with open(file_name, 'r') as f:
        while (True):
            line = f.readline()
            if line.startswith(findLine):
                break
        while (True):
            line = f.readline()
            if line.startswith("*Element"):
                break
        while (True):
            if line.startswith("*Element"):  # we don't care
                line = f.readline()
            elif line.startswith("*"):  # done getting connections
                break
            else:
                strings = line.replace(" ", "").strip().split(",")
                nums = []
                for num in strings:
                    nums.append(int(num))

                connections = addToVals(connections, nums[1:])
                line = f.readline()

    return connections


'''
Function: addToVals
'''


def addToVals(connections, nums):
    """
    Adds connections between nodes to the existing list of connections.

    Parameters:
    connections (list): The existing list of connections.
    nums (list): A list of node numbers that should be connected.

    Returns:
    list: The updated list of connections.
    """

    if len(nums) < 4:
        for num in nums:
            # goto connection[num], add all unique in nums
            for neighbor in nums:
                if neighbor not in connections[num - 1] and neighbor != num:
                    connections[num - 1].append(neighbor)

    elif len(nums) == 4:
        for i, num in enumerate(nums):
            for j, neighbor in enumerate(nums):
                if neighbor not in connections[num - 1] and (
                        i + j) % 2 == 1:  # indices 0,1,2,3 and each is the corner of a square; do not want diagonal or self.
                    # all the ones we want to add are odd+even indices
                    # odd+odd or even+even only occur when adding diagonals or self
                    connections[num - 1].append(neighbor)

    else:
        raise (RuntimeError("Error retrieving connections; can only handle sets of 2, 3, or 4 values"))
    return connections


'''
Function: findLineNum

Returns the line number (not index) that a given string occurs in
'''


def findLineNum(file_location, string):
    """
    Finds the line number in a file where a specified string occurs.

    Parameters:
    file_location (str): The location of the file in which to search.
    string (str): The string to search for.

    Returns:
    int: The line number (not index) where the string occurs.
    """

    lineNum = 1
    f = open(file_location, 'r')
    for line in f:
        if string == line.strip():
            return lineNum
        lineNum += 1
    raise EOFError("String not found", file_location, string)


############### functions for reading csv file once it has been created with nodal coordinates
'''
Function: getFEAData
'''


def getFEAData(FileName, nodes):
    """
    Extracts data from a CSV file for a specified number of nodes.

    Parameters:
    FileName (str): The name of the CSV file.
    nodes (int): The number of nodes to extract data for.

    Returns:
    list: A list of x, y, z coordinates for each node.
    """

    csv = np.genfromtxt(FileName, delimiter=",")
    #    print(csv)
    #    [rows,columns] = csv.shape
    #    print(rows)
    #    print(columns)
    x = np.zeros(nodes)
    y = np.zeros(nodes)
    z = np.zeros(nodes)
    for i in range(0, nodes):
        x[i] = csv[i * 3]
        y[i] = csv[i * 3 + 1]
        z[i] = csv[i * 3 + 2]
    return [x, y, z]


'''
Function: getFEADataCoordinates
'''


def getFEADataCoordinates(FileName):
    """
    Extracts the coordinates from a CSV file.

    Parameters:
    FileName (str): The name of the CSV file.

    Returns:
    list: A list of x, y, z coordinates.
    """

    csv = np.genfromtxt(FileName, delimiter=",")

    # If there are multiple rows, get the last one
    try:
        data = csv[-1, :]
    except IndexError:
        data = csv

    nodes = floor((len(data) / 3))
    x = np.zeros(nodes)
    y = np.zeros(nodes)
    z = np.zeros(nodes)
    for i in range(0, nodes):
        x[i] = data[i * 3]
        y[i] = data[i * 3 + 1]
        z[i] = data[i * 3 + 2]
    return [x, y, z]


'''
Function: getInitialPositions
'''


def getInitialPositions(FileName, nodes):
    """
    Extracts the initial positions of a specified number of nodes from a CSV file.

    Parameters:
    FileName (str): The name of the CSV file.
    nodes (int): The number of nodes to extract positions for.

    Returns:
    list: A list of x, y, z coordinates for each node.
    """

    csv = np.genfromtxt(FileName, delimiter=",")
    x = np.array(csv[:, 1])
    y = np.array(csv[:, 2])
    z = np.array(csv[:, 3])
    return [x, y, z]


## ************************************************************************************************* ##
## ****************************Below is New Functions created by Yutian Yang************************ ##

'''
Function: get_points_below
'''
def get_points_below(file_name, part_name, threshold_percentage):
    """
    Retrieves the points below a specified threshold percentage along the z-axis from a given file and part.

    Parameters:
        file_name (str): The name of the file to extract points from.
        part_name (str): The name of the part to extract points from.
        threshold_percentage (float): The threshold percentage below which points are considered.

    Returns:
        tuple: A tuple containing the following elements:
            - filtered_points (list): A list of the original sort numbers of the filtered points.
            - filtered_count (int): The number of points below the threshold.
            - total_count (int): The total number of points in the part.

    Description:
        This function reads the content of the specified file and extracts the points belonging to the specified part.
        It then determines the minimum and maximum z-values among all the points. Based on the threshold percentage,
        a threshold z-value is calculated. Points whose z-coordinate is below the threshold are considered as filtered points.

        The function returns a tuple containing the original sort numbers of the filtered points, the count of filtered points,
        and the total count of points in the part.

    Example:
        >>> file_name = "input.inp"
        >>> part_name = "MyPart"
        >>> threshold_percentage = 30
        >>> filtered_points, filtered_count, total_count = get_points_below(file_name, part_name, threshold_percentage)
        >>> print(filtered_points)
        [1, 3, 4, 6, 8, 10]
        >>> print(filtered_count)
        6
        >>> print(total_count)
        10
    """
    # Generate an array including all the points from the given file with part
    all_points = np.array(extractPointsForPartFrom(file_name, part_name))

    # Find the minimum and maximum z values
    min_z = np.min(all_points[:, 2])
    max_z = np.max(all_points[:, 2])

    # Calculate threshold z value
    threshold = threshold_percentage * 0.01 * (max_z - min_z) + min_z

    # Get the original sort number of each filtered point
    filtered_points = []
    for i, point in enumerate(all_points):
        if point[2] < threshold:
            filtered_points.append(i + 1)

    # Return the filtered points, filtered count, and total count
    return filtered_points, len(filtered_points), all_points.shape[0]


'''
Function: write_Nset_to_inp_file
'''


# TODO: Merge this function with the exclude function into a new one for inserting the points below some given points.
def write_Nset_to_inp_file(file_name, part, Nset_num, section, Nset_list):
    """
    Adds a new node set (Nset) to an existing .inp file (Abaqus input file) and assigns a shell section to it.

    Parameters:
        file_name (str): The path to the existing .inp file.
        part (str): The name of the part where the Nset will be added.
        Nset_num (int): The number of the new Nset.
        section (str): The name of the shell section to be assigned to the new Nset.
        Nset_list (list of ints): A list of the node indices that belong to the new Nset.

    Description:
        This function reads the content of the existing .inp file specified by 'file_name' and adds a new node set (Nset)
        to the specified 'part'. The Nset is identified by the '*Nset, nset=' keyword followed by the Nset number.

        The function writes the Nset information after the first occurrence of "*Nset, nset=" within the specified part.
        The node indices are written in lines with up to 16 indices per line. The node indices are provided as a list
        of integers in 'Nset_list'.

        After writing the Nset information, the function assigns the specified 'section' to the new Nset. The section is
        written after the next occurrence of "** Section:" within the file.

        If the file does not exist or cannot be opened due to insufficient permissions, an error message is printed,
        and the function returns immediately without making any changes.

    Note:
        - The function assumes that the input file is a valid Abaqus .inp file.
        - It is important to provide valid 'part' and 'section' names to ensure correct placement and assignment.
        - Ensure that the 'Nset_num' is a unique number to avoid conflicts with existing Nsets.

    Example usage:
        >>> write_Nset_to_inp_file('input.inp', 'MyPart', 1, 'MySection', [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
    """
    node_pad = 3  # how big of a space to leave for the data
    line_pad = 16  # how many number in each line

    # print(file_name)

    content = openFile(file_name)

    part = "*Part, name=" + part
    index = 0
    max_index = len(Nset_list) - 1

    with open(file_name, 'w') as f:
        write = False
        found = False
        found_Nset = False
        found_section = False
        section_written = False

        for line in content:
            if part in line:
                found = True

            if found and ("*Nset, nset=" in line):
                found_Nset = True

            if found_Nset and ("** Section:" in line):
                found_section = True

            if found_Nset and not write:
                Nset = "*Nset, nset=_PickedSet" + str(Nset_num) + ", internal, generate" + "\n"
                f.write(Nset)
                write = True

            if write and max_index >= index:
                """
                The  node number is Justified right with a length of 4
                """
                for i in range(0, len(Nset_list), line_pad):
                    Nset_line = ', '.join(str(number).rjust(node_pad) for number in Nset_list[i:i + line_pad])
                    f.write(Nset_line + "\n")
                    index += line_pad
                print("Successfully insert new Nset")

            elif found_section and not section_written:
                section_line = "** Section: " + section + "\n" + "*Shell Section, elset=_PickedSet" + str(
                    Nset_num) + ",\n" \
                               + "material=ATFP_HYPER_highdesity\n" + "2., 5"
                f.write(section_line + "\n")
                section_written = True
                print("Successfully insert new Section")

            f.write(line + "\n")

    '''
    Function: write_new_part_to_inp_file
    '''


def get_dis_Nset_points_list(file_name, part_name, section_name):
    """
    Retrieves a list of node indices from an Abaqus input file (.inp) belonging to a specified dissection Nset.

    Parameters:
        file_name (str): The path to the Abaqus input file (.inp).
        part_name (str): The name of the part where the dissection Nset is located.
        section_name (str): The name of the dissection section.

    Returns:
        list or None: A list of node indices belonging to the dissection Nset, or None if the section is not found.

    Description:
        This function reads the content of the Abaqus input file specified by 'file_name' and searches for the specified 'part_name' and 'section_name' to identify the dissection Nset. The Nset is identified by the '*Nset, nset=' keyword followed by the Nset number.

        The function retrieves the node indices belonging to the dissection Nset by parsing the lines after the Nset definition until it encounters the next section or Nset. The node indices are returned as a list.

        If the specified 'section_name' is not found within the 'part_name', the function prints an error message and returns None.

    Example:
        >>> node_indices = get_dis_Nset_points_list('input.inp', 'MyPart', 'MySection')

    Note:
        - This function assumes that the input file is a valid Abaqus .inp file.
        - The 'part_name' and 'section_name' should match the actual part and section names in the input file.
        - Ensure that the dissection Nset is correctly defined using the '*Nset, nset=' keyword.
        - The function retrieves node indices based on the assumption that they follow the Nset definition and precede the next section or Nset in the input file.
    """
    content = openFile(file_name)
    part = "*Part, name=" + str(part_name)
    dis_section = "** Section: " + str(section_name) + "_dis"

    found_part = False
    found_section = False
    line_number = 0
    set_numbers = {}

    for line in content:
        line_number += 1
        if part in line:
            found_part = True
        if found_part and "*Nset, nset=_PickedSet" in line:
            set_number = line.split("_PickedSet")[1].split(",")[0].strip()
            set_numbers[set_number] = line_number

        if found_part and dis_section in line:
            found_section = True
            break

    if not found_section:
        print("No " + str(section_name) + "_dis found!")
        return None

    line_number += 1
    line = linecache.getline(file_name, line_number)
    exclude_set_number = line.split("_PickedSet")[1].split(",")[0].strip()
    exclude_points_list = []

    line_number = set_numbers[exclude_set_number]
    line = linecache.getline(file_name, line_number + 1)

    while "*Elset, elset=" not in line and "*Nset, nset=" not in line:
            numbers = line.strip().split(",")
            numbers = [int(num.strip()) for num in numbers]
            exclude_points_list.extend(numbers)
            line_number += 1
            line = linecache.getline(file_name, line_number)

    return exclude_points_list


def exclude_points_in_list(original_list, exclude_list):
    """
    Excludes numbers from an original list based on an exclude list and returns a new list.

    Parameters:
        original_list (list): The original list of numbers.
        exclude_list (list): The list of numbers to be excluded.

    Returns:
        list: A new list that contains numbers from the original list excluding those present in the exclude list.

    Example:
        >>> original_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
        >>> exclude_list = [3, 5, 7]
        >>> result_list = exclude_points_in_list(original_list, exclude_list)
        >>> print(result_list)
        [1, 2, 4, 6, 8, 9, 10]
    """
    return [num for num in original_list if num not in exclude_list]

# def write_points_below_excluded_in_inp():



# TODO: Debug the format
def write_new_part_to_inp_file(file_name, part, element_type, points_list, element_list):
    """
    Writes a new part to an existing .inp file (Abaqus input file).

    Parameters:
        file_name (str): The path to the existing .inp file.
        part (str): The name of the new part.
        element_type (str): The type of the elements in the new part.
        points_list (list of 3 floats): A list of the nodes' coordinates.
            Each node is represented as a list of three coordinates [x, y, z].
        element_list (list of ints): A list of the element definitions.
            Each element is defined by three node indices (assuming triangular elements).

    Returns:
        None

    Description:
        This function reads the content of the existing .inp file and writes the new part information before the
        first occurrence of "*Part, name=". The new part information includes the nodes (coordinates) and elements
        (node indices). Each line in the file is padded to ensure proper alignment.

    Note:
        - If the file does not exist or cannot be opened due to insufficient permissions, an error message is printed, and the function returns immediately without making any changes.

    Example:
        >>> write_new_part_to_inp_file('existing_file.inp', 'NewPart', 'C3D4', [[0.0, 0.0, 0.0], [1.0, 0.0, 0.0]], [1, 2, 3])
    """
    element_pad = 4
    node_pad = 7  # how big of a space to leave for the data
    data_pad = 13  # this insures that of a number is 3 digits long it will be padded with spaces to the specified justifaction to maintian the given length
    #    print(file_name)

    content = openFile(file_name)
    with open(file_name, 'w') as f:
        found = False
        first_part = "*Part, name="

        for line in content:
            if first_part in line:
                found = True

            if found:
                part_line = "*Part, name=" + part
                f.write(part_line + "\n")
                f.write("*Node\n")
                for i in range(len(points_list)):
                    coordinates_line = (
                            str(i + 1).rjust(node_pad) + ', '
                            + str(points_list[i][0]).rjust(data_pad) + ', '
                            + str(points_list[i][1]).rjust(data_pad) + ', '
                            + str(points_list[i][2]).rjust(data_pad))
                    f.write(coordinates_line + "\n")
                print("Successfully insert the new part with the coordinates!")

                element = "*Element, type=" + str(element_type)
                f.write(element + "\n")

                for i in range(0, len(element_list), 2):
                    element_line = str(i // 3 + 1)  # add line number
                    if i < len(element_list):
                        element_line += ', ' + str(element_list[i]).rjust(element_pad)
                    if i + 1 < len(element_list):
                        element_line += ', ' + str(element_list[i + 1]).rjust(element_pad)
                    f.write(element_line + "\n")

                print("Successfully insert the new Element")

                end = "*End Part\n" + "**"
                f.write(end + "\n")
                found = False
            f.write(line + "\n")

    print("Successfully insert!")
